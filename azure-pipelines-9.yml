
resources:
  pipelines:
    - pipeline: WebAppCI
      source: Learn14-know.WebApp
      trigger:
        branches:
          include:
            - main

variables:
  PROJECT_NAME: 'WebApp'

  # App Names
  APP_DEV: 'app-dev-app'
  APP_STG: 'app-staging-app'
  APP_PRD: 'app-prod-app'

  # Resource Groups
  RG_DEV: 'RG-DEV'
  RG_STAGING: 'RG-STAGING'
  RG_PRD: 'RG-PROD-App'

  # Azure service connection
  AZURE_SERVICE_CONNECTION: 'Appconnec'

  # Artifact
  ARTIFACT_NAME: 'drop'

stages:
- stage: Deploy_Dev
  displayName: "Deploy to Dev"
  jobs:
  - deployment: DeployDev
    environment: dev
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: "Download Artifact"
            inputs:
              buildType: 'specific'
              project: $(PROJECT_NAME)
              pipeline: 'Learn14-know.WebApp'
              runVersion: 'latest'
              artifact: $(ARTIFACT_NAME)
              path: $(Pipeline.Workspace)/drop

          - task: AzureRmWebAppDeployment@5
            displayName: "Deploy to Dev"
            inputs:
              ConnectionType: 'AzureRM'
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              appType: 'webAppLinux'
              WebAppName: $(APP_DEV)
              ResourceGroupName: $(RG_DEV)
              packageForLinux: "$(Pipeline.Workspace)/drop/DotNetWebApp.zip"
              RuntimeStack: 'DOTNETCORE|8.0'
              DeploymentTypeLinux: 'oneDeploy'


- stage: Deploy_Staging
  displayName: "Deploy to Staging"
  dependsOn: Deploy_Dev
  jobs:
  - deployment: DeployStaging
    environment: staging
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: "Download Latest CI Artifact"
            inputs:
              buildType: 'specific'
              project: $(PROJECT_NAME)
              pipeline: 'Learn14-know.WebApp'
              runVersion: 'latest'
              artifact: $(ARTIFACT_NAME)
              path: $(Pipeline.Workspace)/drop

          - task: AzureRmWebAppDeployment@5
            displayName: "Deploy to Green Slot (Staging)"
            inputs:
              ConnectionType: 'AzureRM'
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              appType: 'webAppLinux'
              WebAppName: $(APP_STG)
              ResourceGroupName: $(RG_STAGING)
              SlotName: 'green'
              packageForLinux: "$(Pipeline.Workspace)/drop/DotNetWebApp.zip"
              RuntimeStack: 'DOTNETCORE|8.0'
              DeploymentTypeLinux: 'oneDeploy'

          
          - task: AzurePowerShell@5
            displayName: "Health Check – Green Slot (Staging)"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              ScriptType: InlineScript
              Inline: |
                $slotUrl = "https://$(APP_STG)-green.azurewebsites.net/health"

                Write-Host "Starting health check for slot:"
                Write-Host $slotUrl
                Write-Host "--------------------------------"

                $maxRetries = 30
                $delaySeconds = 10

                for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
                  try {
                    $response = Invoke-WebRequest `
                      -Uri $slotUrl `
                      -Method GET `
                      -TimeoutSec 10 `
                      -SkipHttpErrorCheck

                    $statusCode = $response.StatusCode
                    Write-Host "Attempt $attempt → HTTP $statusCode"

                    if ($statusCode -eq 200) {
                      Write-Host " Green slot is healthy"
                      exit 0
                    }
                  }
                  catch {
                    Write-Host "Attempt $attempt → Exception:"
                    Write-Host $_.Exception.Message
                  }

                  Start-Sleep -Seconds $delaySeconds
                }

                Write-Error " Green slot did not become healthy"
                exit 1
              azurePowerShellVersion: LatestVersion

         
          - task: AzureAppServiceManage@0
            displayName: "Swap Green → Production (Staging)"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              Action: 'Swap Slots'
              WebAppName: $(APP_STG)
              ResourceGroupName: $(RG_STAGING)
              SourceSlot: 'green'


- stage: Deploy_Prod
  displayName: "Deploy to Production"
  dependsOn: Deploy_Staging
  jobs:
  - deployment: DeployProd
    environment: production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: "Download Latest CI Artifact"
            inputs:
              buildType: 'specific'
              project: $(PROJECT_NAME)
              pipeline: 'Learn14-know.WebApp'
              runVersion: 'latest'
              artifact: $(ARTIFACT_NAME)
              path: $(Pipeline.Workspace)/drop

          # 1️⃣ Deploy to BLUE slot
          - task: AzureRmWebAppDeployment@5
            displayName: "Deploy to Blue Slot (Production)"
            inputs:
              ConnectionType: 'AzureRM'
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              appType: 'webAppLinux'
              WebAppName: $(APP_PRD)
              ResourceGroupName: $(RG_PRD)
              SlotName: 'blue'
              packageForLinux: "$(Pipeline.Workspace)/drop/DotNetWebApp.zip"
              RuntimeStack: 'DOTNETCORE|8.0'
              DeploymentTypeLinux: 'oneDeploy'

          # 2️⃣ Health check BLUE slot
          - task: AzurePowerShell@5
            displayName: "Health Check – Blue Slot (Production)"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              ScriptType: InlineScript
              Inline: |
                $slotUrl = "https://$(APP_PRD)-blue.azurewebsites.net/health"

                Write-Host "Waiting for Blue slot to be healthy..."
                for ($i = 1; $i -le 30; $i++) {
                  try {
                    $response = Invoke-WebRequest -Uri $slotUrl -UseBasicParsing -TimeoutSec 10
                    if ($response.StatusCode -eq 200) {
                      Write-Host "Blue slot is healthy"
                      exit 0
                    }
                    Write-Host "Status=$($response.StatusCode) retrying..."
                  }
                  catch {
                    Write-Host "Health check failed, retrying..."
                  }
                  Start-Sleep -Seconds 10
                }

                Write-Error "Blue slot did not become healthy"
                exit 1
              azurePowerShellVersion: LatestVersion

          # 3️⃣ Swap BLUE → Production
          - task: AzureAppServiceManage@0
            displayName: "Swap Blue → Production"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              Action: 'Swap Slots'
              WebAppName: $(APP_PRD)
              ResourceGroupName: $(RG_PRD)
              SourceSlot: 'blue'
